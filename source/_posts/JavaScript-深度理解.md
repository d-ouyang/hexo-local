---
title: JavaScript 深度理解
date: 2017-06-05 16:49:11
categories:
- 技术
- 前端技术
tags:
- javascript
- JQuery
- 内存
- 作用域
- 作用域链
- 闭包
- 变量对象
- 执行环境

---

#### 咸鱼的自省

*之前都不会去深究 js 数据内部的一些具体的情况，不知其原理和运行规律，只会写一写死代码。知道深入了解后才发现自己之前和咸鱼没啥区别*。

#### 栈内存与堆内存

js 并没有严格意义上的区分栈内存与堆内存，但是仍可以以堆栈数据结构的思路进行处理。在此会涉及到**执行环境、作用域、作用域链、垃圾回收机制、闭包**等各种知识，可能会揉起来讲，只是用内存管理抛砖引玉，因为我认为他们之间的关系并不是独立的。书上之所以会分开讲是因为每一节的侧重点不一样而已。

##### 栈（stack）

很多博主都对栈的存取方式进行了形象的类比，如乒乓球、羽毛球的存取方式，即栈空间**先进后出，后进先出**的特点。

{% asset_img blog2.png 栈空间类比 %} 

后面的函数运行时给以很好的解释这种特性，典型的就是**递归**。

##### 堆（heap）

对于堆的存取方式的类比为书架上的书，存取数据并不会受先后书序的影响。

{% asset_img blog1.png 变量对象和堆内存空间 %} 

##### 个人理解：

一开始，栈中的数据本身是不存在先后顺序的，他们是一群有固定大小的值，游离在栈空间中，程序员可以直接使用。在程序员没有声明变量时（即没有给对应的值取名时），是没有变量名的一些值。一旦程序员给这些值取了名字，如上图 2 ，这些值就成了有名字的变量对象。

```javascript
var a = 1 // 1 : 即 栈内存中的数据 1 对应的名字为 a
var b = 1// 1 : 即 栈内存中的数据 1 对应的名字为 b
// 在程序中，a、b、1 都可被程序员直接使用，都代表的是 1。
// 说明栈内数据值虽然固定，但对应的名字是程序员来控制，可以是一对多的映射，但名对值得映射只能是一对一，如下：
 b = 10 // 10 : 程序员把名字 b 赋予给了值 10，同时 1 已不能被 b 所表示，b 只能代表 10
// 在程序中， b、10 都可以被程序员直接使用。
// 而且，虽然 b 声明在 a 之后，但在使用时仍可先取 b 的值并使用，并不遵循栈空间先进后出，后进先出的特点。所以入栈和出栈并不是在声明的时候确定，而是在使用时确定（其实一开始是全局上下文入栈，先抛开此栈不说）。在使用时，上面的变量对象就会变成活动对象

// 特别注意：
var i
console.log(i) // undefined
var i = 10
var i
console.log(i) // 10
var i = undefined
console.log(i) // undefined
// 虽然 var 一个变量不给值所打印出来的结果为 undefined，但与直接把 undefined 赋值给这个变量有区别，后者可以重写变量，前者不可以
```

而栈数据的存取特点一般在函数中可以很直观的得以体现，即产生上**下文执行环境**时。下面的例子很好的说明栈空间先进后出，后进先出的特点。

**例 1：**

```javascript
function foo(i) {
    if (i < 0) return;
    console.log('begin:' + i);
    foo(i - 1);
    console.log('end:' + i);
}
foo(2);
// 打印结果：
begin:2
begin:1
begin:0
end:0
end:1
end:2
```

**分析：**

执行 foo(2) 时，产生一个上下文环境（已入栈开始，出栈结束），以 2 入栈， foo(2) 在栈底；

当执行到 foo(i - 1) 时，产生一个新的上下文环境（新栈），以 1 入栈，foo(1)  在第二层，栈底以 2 入栈但并未出栈；

当再次执行到 foo(i - 1) 时，又产生一个新的上下文环境（新栈），以 0 入栈，foo(0)  在第三层，第二层以 1 入栈但并未出栈；

以此推，当再次执行到foo(i - 1) 时，又产生一个新的上下文环境（新栈），以 -1 入栈，foo(-1)  在第四层，但在执行 return 语句时结束上下文环境出栈，第三层暴露在栈顶，执行未完成语句 console.log('end:' + i)

第三层执行完毕后出栈，第二层暴露在栈顶，执行未完成语句 console.log('end:' + i)

以此推，直到栈底  foo(2)  执行完最后一条语句 console.log('end:' + i) 出栈，结束。

不明白，看图：

{% asset_img blog0.png 执行流程图 %} 

**例2：**

```javascript
var num = 5
function star (num) {
    if (num > 3) {
        star(--num)
    }
    console.log(num)
}
star(num)
// 打印结果：3, 3, 4
```

##### **分析：**

这个分析用更笨的方式还原，如下：

```javascript
star(num) // 执行后
====================
var num = 5 
if (num > 3) { // num = 5 入栈 栈底(第一层)
    num = num - 1 // num = 4 栈底(第一层)
    if (num > 3) { // num = 4 入栈 第二层
		num = num - 1 // num = 3 第二层
        if (num > 3) { // num = 3 入栈 第三层
           // 因为不满足条件，无法进入 if 语句内部建立新栈，则继续执行第三层可执行语句
        }
        console.log(num) // num = 3 出栈 第三层结束
    }
    console.log(num) // num = 3 出栈 第二层结束
}
console.log(num) // num = 4 出栈 栈底（第一层）结束
// 所以打印结果为 3, 3, 4
// 由此可见，js 的执行是单线程的
```

**例 3：**

```javascript
function f1() {
    var n = 999;
    function f2() {
        console.log(n+=1); 
    }
    return f2;
    console.log('n：' + n)
}
var result = f1();
result(); // 1000
```

**分析：**

上面是一个**闭包**的例子，从**执行环境、作用域链和变量对象**的角度来解析。

执行 f1() 时便进入函数 f1 的**执行环境**，而这个环境都有一个与之相关联的**变量对象**，这个环境便被推到**栈**顶。

代码在当前环境中执行时，**变量对象**都会生成一个**作用域链**，但**作用域链**包含的对象可能不止一个，在此插入一个例子来解释这些名词，如下：

**例 3+：**

```javascript
var name = 'WAN'
function changeName() {
    var other_name = 'georgina'
    function swapName() {
        var tempName = other_name
        other_name = name
        name = tempName
        // 这里可以访问变量 tempName、other_name 和 name
    }
    // 这里可以访问变量 name 和 other_name
    swapName()
}
// 这里可以访问变量name
changeName()
```

**分析：**

以上涉及三个执行环境：全局环境、changeName() 的局部环境和 swapName() 的局部环境。

全局环境会产生一个**变量对象**，此对象包含变量 name 和函数 changeName()，它生成一个**作用域链**，这个**作用域链**只包含了全局环境产生的**变量对象**，在此执行环境中，这个**变量对象**在这个**作用域链**的最前端，可以理解为当前执行环境在栈顶。

changeName() 的局部环境也会产生一个**变量对象**，包含变量 other_name 、函数 swapName()和默认对象 arguments（此对象不存在于全局环境中），它也生成一个**作用域链**，包含当**前执行环境产生的变量对象**和**全局环境产生的变量对象**。当 changeName() 执行时，当前执行环境被推至栈顶，当前环境的变量对象位于作用域链最前端。执行时，它会从当前变量对象中搜索变量名和函数名，如果搜索不到，则进入上一级的作用域链，以此类推，找到相关变量或函数立即停止搜索。

同理，swapName() 的局部环境也会产生一个**变量对象**，包含变量 tempName 和默认对象 arguments，它也生成一个**作用域链**，不同的是这个**作用域链**包含三个**变量对象**：**当前执行环境产生的变量对象**、上一级 changeName() 的局部环境也会产生一个**变量对象**和**全局环境产生的变量对象**。

以上例子中，局部环境在脱离执行环境时，变量对象中相应的变量将被**解除引用**（无法访问到这些变量了），而全局变量需要手动来解除。但解除值引用并不意味着释放了改值所占内存，它真正的作用是让这个值脱离执行环境，相当于做个标记以便被周期工作的垃圾收集器销毁并回收内存。







